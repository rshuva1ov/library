// --- ТИПЫ ДАННЫХ ---

let a: number = 0 // число
let b: string = 'Hi' // строка
let c: boolean = true // логический тип
let d: object = {} // объект
let e: { foo: string } = { foo: 'bar' } // объект со свойством 'foo' строкового типа
let f: any = undefined // любой тип (нативное поведение JS)
let g: null = null // тип null
let h: undefined = undefined // тип undefined, но присвоить другой тип нельзя. Хотя в JS все переменные изначально ииеют значение undefined

// --- Функции ---

function i(a: number, b: number): number {  // функция, принимающая параметры определённого типа, возвращающая определённый тип (сигнатура функции)
  return a + b;
}

let j = (a: number, b: number): number => a + b;  // сигнатура стрелочной функции

function k(a: number, b: number): number  // перегрузка функции
function k(a: string, b: number): string  // описываем возможные кейсы
function k(a: any, b: any): any {  // сама функция прописывается с типами any
  if (typeof a === 'number') {
    return a + b;
  }
  
  return `${a} ${b}`;
}

function l(a: string): void {  // функция, выполняющая что либо, но не возвращающая ничего (отсутствует return)
  alert(a);
}

function m(a: string): never {  // функция не завершается (проброс исключения в данном случае)
  throw new Error(a);
}

// --- ПРИВЕДЕНИЕ ТИПОВ ---

let n: unknown = 1 // неизвестный тип

/* переменную типа unknown нельзя присвоить другой переменной, например, типа number
 * тип нужен как замена any (присвоение any в другую переменную не вызывает ошибки, а это небезопасно)
 * присвоение этого типа должно происходить с приведением, как это указано ниже
 */

let o: number = <number>n // явное приведение типа данных, в данном случае значение переменной n в число
// let o: number = n as number - эквивалентная запись приведения типа

let p: string = 'foo';
let q: number = (<string>p).length // приведение типа переменной для безопасного доступа к её методам
// в данном случае можно прочитать как "взять переменную p как строку и получить её длину с помощью метода строки length"

// --- ОБЪЕДИНЕНИЕ ТИПОВ ---

let r: string | number = 0 // переменная может содержать как строку так и число
type R = string | number // объявление объединённого типа, теперь переменную r можно объявить записью "let r: R = 0"

type S = 1 | 2 | 3 // тип, содержащий допустимые значения переменной
let s: S = 2 // всё ок, так как значение допустимо
s = 5 // ошибка. тип S не допускает значение 5
// также значения и типы можно комбинировать между собой, например, type A = 1 | 'foo' | boolean

type T = { a: string } | { b: string };  // объединение объектов
let t: T = { a: 'foo' } // также допустимы значения "{ b: 'bar' }", "{ a: 'foo', b: 'bar' }"

// --- ПЕРЕСЕЧЕНИЕ ТИПОВ ---

type U = { a: string } & { b: string } // объект должен содержать оба свойства
let u: U = { a: 'foo', b: 'bar' }
u = { a: 'foo' } // ошибка, нет строкового свойства b

// --- НЕОБЯЗАТЕЛЬНЫЕ СВОЙСТВА ТИПА ---

type V = { a: string, b?: string } // здесь b - необязательное свойство
let v: V = { a: 'foo' } // такое присваивание допустимо

// --- МАССИВЫ ---

let w: number[] = [ 0, 1, 2 ]; // объявление массива, содержащего данные только типа number
// эквивалентная версия - let w: Array<number> = [ 0, 1, 2 ];

let x: [number, string] = [1, 'foo'] // кортеж, в примере массив должен состоять из двух значений типа number и string

// --- ПЕРЕЧИСЛЕНИЯ ---

enum Y {
  A = 'foo',
  B = 'bar'
}

console.log(Y.A, Y.B); // -> "foo bar", если значения не установлены явно, то вывод будет "0, 1", то есть просто индексы
console.log(Y['foo'], Y.['bar']); // -> "A, B"
// в данном случае в скомпилированном файле будет добавлена функция Y, но есть другой способ объявления перечисления:

const enum Z {
  A,
  B
}

console.log(Z.A, Z.B) // -> "0, 1"
// отличие данного объявления перечисления заключается в том, что в скомпилированном файле не будет функции, а будет просто console.log("0 /*A*/, 1 /*B*/")